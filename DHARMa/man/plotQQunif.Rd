% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plots.R
\name{plotQQunif}
\alias{plotQQunif}
\title{Quantile-quantile plot for a uniform distribution}
\usage{
plotQQunif(simulationOutput, testUniformity = TRUE, testOutliers = TRUE,
  testDispersion = TRUE, ...)
}
\arguments{
\item{simulationOutput}{a DHARMa simulation output (class DHARMa).}

\item{testUniformity}{if T, the function \link{testUniformity} will be called and the result will be added to the plot.}

\item{testOutliers}{if T, the function \link{testOutliers} will be called and the result will be added to the plot.}

\item{testDispersion}{if T, the function \link{testDispersion} will be called and the result will be added to the plot.}

\item{...}{arguments to be passed on to \link[gap:qqunif]{gap::qqunif}.}
}
\description{
The function produces a uniform quantile-quantile plot from a DHARMa output. Optionally, tests for uniformity, outliers and dispersion can be added.
}
\details{
The function calls qqunif() from the R package gap to create a quantile-quantile plot for a uniform distribution, and overlays tests for particular distributional problems as specified.
When tests are displayed, significant p-values are highlighted in the color red by default. This can be changed by setting \code{options(DHARMaSignalColor = "red")} to a different color. See \code{getOption("DHARMaSignalColor")} for the current setting.
}
\examples{
testData = createData(sampleSize = 200, family = poisson(),
                      fixedEffects = c(1,1),
                      randomEffectVariance = 1, numGroups = 10)
testData$Environment2[1] = NA
fittedModel <- glm(observedResponse ~ Environment1 + Environment2,
                   family = "poisson", data = testData)
simulationOutput <- simulateResiduals(fittedModel = fittedModel)

######### main plotting function #############

# for all functions, quantreg = T will be more
# informative, but slower

plot(simulationOutput, quantreg = FALSE)

#############  Distribution  ######################

plotQQunif(simulationOutput = simulationOutput,
           testDispersion = FALSE,
           testUniformity = FALSE,
           testOutliers = FALSE)

hist(simulationOutput )

#############  residual plots  ###############

# Default in DHARMa is to show predictions rank transformed
# if you want plots based on raw predictions, use rank = F
plotResiduals(simulationOutput, rank = FALSE)

# smooth scatter plot - default for large datasets with n > 10,000
plotResiduals(simulationOutput, rank = TRUE, smoothScatter = TRUE)

# It is very advisable to plot the residual against all predictors
# the following syntax uses the predictor values from the fitted model
plotResiduals(simulationOutput, form = ~ Environment1)


# plot against all predictors
plotResiduals(simulationOutput, form = ~.)

# if pred is a factor, or if asFactor = TRUE, will produce a boxplot
plotResiduals(simulationOutput, form = ~group)

# plot residuals against multiple predictors at once
plotResiduals(simulationOutput, form = ~Environment1 + Environment2)

# plot residuals against a predictor for a specific group level, here group 1
plotResiduals(simulationOutput, form = ~Environment1|group == "1")

# or in a grid for multiple group levels, e.g. groups 1 to 4
par(mfrow= c(2,2))
for(g in unique(testData$group)[1:4]) {
  plotResiduals(simulationOutput, form = ~Environment1|group == g, xlab = paste("group", g))
}
par(mfrow= c(1,1))




# alternatively, you can plot against a variable from the global environment
# in this case, the model function automatically removed one row of observations
# because there was an NA in Environment2. When using the variable Environment1
# from the global environment, we have to remove this observation as well
plotResiduals(simulationOutput,
              form = testData$Environment1[complete.cases(testData)])



# to diagnose overdispersion and heteroskedasticity it can be useful to
# display residuals as absolute deviation from the expected mean 0.5
plotResiduals(simulationOutput, absoluteDeviation = TRUE)

# All these options can also be provided to the main plotting function

# If you want to plot summaries per group, use recalculateResiduals
# with group as a formula (recommended, handles NAs automatically)
simulationOutput = recalculateResiduals(simulationOutput, group = ~group)
plot(simulationOutput)
# we see one residual point per RE

# with group as variable in your environment
# but then you need to exclude NAs by hand
simulationOutput = recalculateResiduals(simulationOutput, group = testData$group[-1])

# you can also select subsets of the data using sel
# with formula syntax (recommended, handles NAs automatically)
simulationOutput = recalculateResiduals(simulationOutput, sel = ~Environment1<0.5)

# as condition based on a variable in your environment (exclude NAs by hand)
simulationOutput = recalculateResiduals(simulationOutput, sel = testData$Environment1[-1]<0.5)

# or combine group and sel
simulationOutput = recalculateResiduals(simulationOutput, group = ~group, sel = ~Environment1<0.5)

# or as subset of rows
# (note: order of rows is based on residuals, not on original dataframe)
# not run, because of warning:
# simulationOutput = recalculateResiduals(simulationOutput, sel = 1:20)



}
\seealso{
\link{plotSimulatedResiduals}, \link{plotResiduals}
}
